# -*- coding: utf-8 -*-
# A collection of callables and tools for creating them, that may be used for
# the optics-callable part of a Surface object.

import optics
import ray_bundle
import numpy as N

class Reflective(object):
    """
    Generates a function that represents the optics of an opaque, absorptive
    surface with specular reflections.
    
    Arguments:
    absorptivity - the amount of energy absorbed before reflection.
    
    Returns:
    refractive - a function with the signature required by Surface.
    """
    def __init__(self, absorptivity):
        self._abs = absorptivity
    
    def __call__(self, geometry, rays, selector):
        outg = rays.inherit(selector,
            vertices=geometry.get_intersection_points_global(),
            direction=optics.reflections(
                rays.get_directions()[:,selector], geometry.get_normals()),
            energy=rays.get_energy()[selector]*(1 - self._abs),
            parents=selector)
        return outg

perfect_mirror = Reflective(0)

class ReflectiveReceiver(Reflective):
    """
    This optics manager remembers all of the locations where rays hit it
    in all iterations, and the energy absorbed from each ray. The surface is 
    reflective, but by default its absorptivity is 1. The energy remembered
    is the incoming energy, not that remaining after reflection.
    """
    def __init__(self, absorptivity=1.):
        Reflective.__init__(self, absorptivity)
        self._absorbed = []
        self._hits = []
    
    def __call__(self, geometry, rays, selector):
        self._absorbed.append(rays.get_energy()[selector]*self._abs)
        self._hits.append(geometry.get_intersection_points_global())
        return Reflective.__call__(self, geometry, rays, selector)
    
    def get_all_hits(self):
        """
        Aggregate all hits from all stages of tracing into joined arrays.
        
        Returns:
        absorbed - the energy absorbed by each hit-point
        hits - the corresponding global coordinates for each hit-point.
        """
        if not len(self._absorbed):
            return N.array([]), N.array([]).reshape(3,0)
        
        return N.hstack([a for a in self._absorbed if len(a)]), \
            N.hstack([h for h in self._hits if h.shape[1]])

class AbsorberReflector(Reflective):
    """
    This optics manager behaves similarly to the ReflectiveReceiver class,
    but adds directionality. In this way a simple one-side receiver doesn't
    necessitate an extra surface in the back.
    """
    def __call__(self, geometry, rays, selector):
        """
        Rays coming from the "up" side are reflected like in a Reflective
        instance, rays coming from the "down" side have their energy set to 0.
        As usual, "up" is the surface's Z axis.
        """
        outg = Reflective.__call__(self, geometry, rays, selector)
        energy = outg.get_energy()
        proj = N.sum(rays.get_directions()[:,selector] * geometry.up()[:,None], axis=0)
        energy[proj > 0] = 0
        outg.set_energy(energy)
        return outg
        
class RefractiveHomogenous(object):
    """
    Represents the optics of a surface bordering homogenous media with 
    constant refractive index on each side. The specific index in which a
    refracted ray moves is determined by toggling between the two possible
    indices.
    """
    def __init__(self, n1, n2):
        """
        Arguments:
        n1, n2 - scalars representing the homogenous refractive index on each
            side of the surface (order doesn't matter).
        """
        self._ref_idxs = (n1, n2)
    
    def toggle_ref_idx(self, current):
        """
        Determines which refractive index to use based on the refractive index
        rays are currently travelling through.

        Arguments:
        current - an array of the refractive indices of the materials each of 
            the rays in a ray bundle is travelling through.
        
        Returns:
        An array of length(n) with the index to use for each ray.
        """
        return N.where(current == self._ref_idxs[0], 
            self._ref_idxs[1], self._ref_idxs[0])
    
    def __call__(self, geometry, rays, selector):
        if len(selector) == 0:
            return ray_bundle.empty_bund()
        
        n1 = rays.get_ref_index()[selector]
        n2 = self.toggle_ref_idx(n1)
        refr, out_dirs = optics.refractions(n1, n2, \
            rays.get_directions()[:,selector], geometry.get_normals())
        
        if not refr.any():
            return perfect_mirror(geometry, rays, selector)
        
        # Reflected energy:
        R = N.ones(len(selector))
        R[refr] = optics.fresnel(rays.get_directions()[:,selector][:,refr],
            geometry.get_normals()[:,refr], n1[refr], n2[refr])
        
        # The output bundle is generated by stacking together the reflected and
        # refracted rays in that order.
        inters = geometry.get_intersection_points_global()
        reflected_rays = rays.inherit(selector, vertices=inters,
            direction=optics.reflections(
                rays.get_directions()[:,selector],
                geometry.get_normals()),
            energy=rays.get_energy()[selector]*R,
            parents=selector)
        
        refracted_rays = rays.inherit(selector[refr], vertices=inters[:,refr],
            direction=out_dirs, parents=selector[refr],
            energy=rays.get_energy()[selector][refr]*(1 - R[refr]),
            ref_index=n2[refr])
        
        return reflected_rays + refracted_rays
